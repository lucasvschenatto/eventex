{"errors":[],"warnings":[],"version":"1.13.0","hash":"e24257a858d774be76bb","publicPath":"","assetsByChunkName":{"main":"textMask.js"},"assets":[{"name":"textMask.js","size":9276,"chunks":[0],"chunkNames":["main"],"emitted":true},{"name":"stats.json","size":0,"chunks":[],"chunkNames":[]}],"chunks":[{"id":0,"rendered":true,"initial":true,"entry":true,"extraAsync":false,"size":29104,"names":["main"],"files":["textMask.js"],"hash":"0da68a891f48d13b628f","parents":[],"modules":[{"id":0,"identifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","name":"./angular2/src/angular2TextMask.ts","index":0,"index2":7,"size":5293,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"failed":false,"errors":0,"warnings":0,"reasons":[],"source":"\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar componentHelpers_1 = require('../../core/src/componentHelpers');\nvar core_1 = require('angular2/core');\nvar common_1 = require('angular2/common');\nvar MaskedInputDirective = (function () {\n    function MaskedInputDirective(el, model) {\n        this.model = model;\n        this.textMaskConfig = { mask: '', guide: true, placeholderCharacter: undefined };\n        this.inputElement = el.nativeElement;\n    }\n    MaskedInputDirective.prototype.setComponentInitialState = function (_a) {\n        var inputValue = _a.inputValue, mask = _a.mask, guide = _a.guide, placeholderChar = _a.placeholderChar;\n        var _b = componentHelpers_1.getComponentInitialState({\n            inputValue: inputValue,\n            mask: mask,\n            guide: guide,\n            placeholderChar: placeholderChar\n        }), conformedInput = _b.conformedInput, componentPlaceholder = _b.componentPlaceholder;\n        this.conformedInput = conformedInput;\n        this.componentPlaceholder = componentPlaceholder;\n        this.inputElement.placeholder = (this.inputElement.placeholder !== undefined) ?\n            this.inputElement.placeholder :\n            this.componentPlaceholder;\n        this.model.valueAccessor.writeValue(conformedInput);\n        this.updateModel(conformedInput);\n    };\n    MaskedInputDirective.prototype.ngOnInit = function (_a) {\n        var _b = _a === void 0 ? this.textMaskConfig : _a, mask = _b.mask, guide = _b.guide, placeholderChar = _b.placeholderCharacter;\n        this.setComponentInitialState({ inputValue: this.model.viewModel, mask: mask, guide: guide, placeholderChar: placeholderChar });\n    };\n    MaskedInputDirective.prototype.ngOnChanges = function (_a) {\n        var textMaskConfig = _a.textMaskConfig;\n        var _b = textMaskConfig.currentValue, currentMask = _b.mask, currentGuide = _b.guide, currentPlaceholderChar = _b.placeholderCharacter, _c = textMaskConfig.previousValue, previousMask = _c.mask, previousGuide = _c.guide, previousPlaceholderChar = _c.placeholderCharacter;\n        if (currentMask !== previousMask ||\n            currentGuide !== previousGuide ||\n            currentPlaceholderChar !== previousPlaceholderChar) {\n            this.setComponentInitialState({\n                inputValue: this.model.viewModel,\n                mask: currentMask,\n                guide: currentGuide,\n                placeholderChar: currentPlaceholderChar\n            });\n        }\n    };\n    MaskedInputDirective.prototype.onInput = function (userInput) {\n        if (userInput === void 0) { userInput = ''; }\n        var _a = this, _b = _a.textMaskConfig, mask = _b.mask, guide = _b.guide, placeholderChar = _b.placeholderCharacter, placeholder = _a.componentPlaceholder, previousConformedInput = _a.conformedInput;\n        var _c = componentHelpers_1.processComponentChanges({\n            userInput: userInput,\n            placeholder: placeholder,\n            previousConformedInput: previousConformedInput,\n            mask: mask,\n            guide: guide,\n            placeholderChar: placeholderChar,\n            currentCaretPosition: this.inputElement.selectionStart\n        }), adjustedCaretPosition = _c.adjustedCaretPosition, conformedInput = _c.conformedInput;\n        this.conformedInput = conformedInput;\n        this.model.valueAccessor.writeValue(conformedInput);\n        componentHelpers_1.safeSetSelection(this.inputElement, adjustedCaretPosition);\n    };\n    MaskedInputDirective.prototype.updateModel = function (conformedUserInput) {\n        this.model.viewToModelUpdate(conformedUserInput);\n    };\n    __decorate([\n        core_1.Input('textMask'), \n        __metadata('design:type', Object)\n    ], MaskedInputDirective.prototype, \"textMaskConfig\", void 0);\n    MaskedInputDirective = __decorate([\n        core_1.Directive({\n            selector: 'input[textMask][ngModel]',\n            host: {\n                '(input)': 'onInput($event.target.value)',\n                '(keyup)': 'updateModel($event.target.value)'\n            }\n        }), \n        __metadata('design:paramtypes', [core_1.ElementRef, common_1.NgModel])\n    ], MaskedInputDirective);\n    return MaskedInputDirective;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = MaskedInputDirective;\nexports.Directive = MaskedInputDirective;\nvar conformToMask_1 = require('../../core/src/conformToMask');\nexports.conformToMask = conformToMask_1.default;\nvar utilities_1 = require('../../core/src/utilities');\nexports.convertMaskToPlaceholder = utilities_1.convertMaskToPlaceholder;\n"},{"id":1,"identifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/utilities.js","name":"./core/src/utilities.js","index":3,"index2":1,"size":3758,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","module":"./angular2/src/angular2TextMask.ts","moduleName":"./angular2/src/angular2TextMask.ts","type":"cjs require","userRequest":"../../core/src/utilities","loc":"94:18-53"},{"moduleId":2,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/conformToMask.js","module":"./core/src/conformToMask.js","moduleName":"./core/src/conformToMask.js","type":"cjs require","userRequest":"./utilities.js","loc":"8:17-42"},{"moduleId":4,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/adjustCaretPosition.js","module":"./core/src/adjustCaretPosition.js","moduleName":"./core/src/adjustCaretPosition.js","type":"cjs require","userRequest":"./utilities.js","loc":"8:17-42"},{"moduleId":5,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/componentHelpers.js","module":"./core/src/componentHelpers.js","moduleName":"./core/src/componentHelpers.js","type":"cjs require","userRequest":"./utilities.js","loc":"18:17-42"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertMaskToPlaceholder = convertMaskToPlaceholder;\nexports.unescapeMask = unescapeMask;\nexports.tokenize = tokenize;\nexports.isAcceptableCharacter = isAcceptableCharacter;\nexports.potentiallyTransformCharacter = potentiallyTransformCharacter;\nexports.getIndexOfFirstChange = getIndexOfFirstChange;\nexports.isString = isString;\nexports.isNumber = isNumber;\n\nvar _constants = require('./constants.js');\n\nfunction convertMaskToPlaceholder(_ref) {\n  var _ref$mask = _ref.mask;\n  var mask = _ref$mask === undefined ? '' : _ref$mask;\n  var _ref$placeholderChar = _ref.placeholderChar;\n  var placeholderChar = _ref$placeholderChar === undefined ? _constants.placeholderCharacter : _ref$placeholderChar;\n\n  if (mask.indexOf(placeholderChar) !== -1) {\n    console.log('Text Mask received placeholder character: ', placeholderChar); // eslint-disable-line\n    console.log('Text Mask received mask: ', mask); // eslint-disable-line\n\n    throw new Error('Placeholder character must not be used as part of the mask. Please specify a character ' + 'that is not present in your mask as your placeholder character.');\n  }\n\n  var escaping = false;\n  var placeholder = '';\n\n  for (var i = 0; i < mask.length; i++) {\n    var character = mask[i];\n\n    if (character === '\\\\' && escaping !== true) {\n      escaping = true;\n      placeholder += '';\n      continue;\n    }\n\n    if (escaping === true) {\n      escaping = false;\n      placeholder += character;\n      continue;\n    }\n\n    placeholder += _constants.maskingCharacters.indexOf(character) !== -1 ? placeholderChar : character;\n  }\n\n  return placeholder;\n}\n\nfunction unescapeMask() {\n  var mask = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n  return mask.replace(/\\\\./g, ' ');\n}\n\nfunction tokenize() {\n  var string = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n  return string.split('');\n}\n\nfunction isAcceptableCharacter() {\n  var character = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var maskingCharacter = arguments[1];\n\n  switch (maskingCharacter) {\n    case _constants.maskingCharactersEnums.numeric:\n      return isNumeric(character);\n\n    case _constants.maskingCharactersEnums.uppercase:\n    case _constants.maskingCharactersEnums.lowercase:\n    case _constants.maskingCharactersEnums.alphabetic:\n      return isAlphabetic(character);\n\n    case _constants.maskingCharactersEnums.alphanumeric:\n      return isNumeric(character) || isAlphabetic(character);\n\n    case _constants.maskingCharactersEnums.any:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction potentiallyTransformCharacter() {\n  var character = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var maskingCharacter = arguments[1];\n\n  switch (maskingCharacter) {\n    case _constants.maskingCharactersEnums.uppercase:\n      return character.toUpperCase();\n\n    case _constants.maskingCharactersEnums.lowercase:\n      return character.toLowerCase();\n\n    default:\n      return character;\n  }\n}\n\nfunction isNumeric(character) {\n  return !isNaN(character) && character !== ' ';\n}\n\nfunction isAlphabetic(character) {\n  return (/^[a-zA-Z]+$/.test(character)\n  );\n}\n\nfunction getIndexOfFirstChange(stringOne, stringTwo) {\n  var longestLength = stringOne.length > stringTwo.length ? stringOne.length : stringTwo.length;\n\n  for (var i = 0; i < longestLength; i++) {\n    if (stringOne[i] !== stringTwo[i]) {\n      return i;\n    }\n  }\n\n  return null;\n}\n\nfunction isString(value) {\n  return typeof value === 'string' || value instanceof String;\n}\n\nfunction isNumber(value) {\n  return value && value.length === undefined && !isNaN(value);\n}"},{"id":2,"identifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/conformToMask.js","name":"./core/src/conformToMask.js","index":5,"index2":3,"size":7817,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","module":"./angular2/src/angular2TextMask.ts","moduleName":"./angular2/src/angular2TextMask.ts","type":"cjs require","userRequest":"../../core/src/conformToMask","loc":"92:22-61"},{"moduleId":5,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/componentHelpers.js","module":"./core/src/componentHelpers.js","moduleName":"./core/src/componentHelpers.js","type":"cjs require","userRequest":"./conformToMask.js","loc":"14:21-50"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = conformToMask;\n\nvar _utilities = require('./utilities.js');\n\nvar _constants = require('./constants.js');\n\nfunction conformToMask() {\n  var userInput = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var mask = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n  var config = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n  // These configurations tell us how to conform the mask\n  var _config$guide = config.guide;\n  var guide = _config$guide === undefined ? true : _config$guide;\n  var _config$previousConfo = config.previousConformedInput;\n  var previousConformedInput = _config$previousConfo === undefined ? '' : _config$previousConfo;\n  var _config$placeholderCh = config.placeholderChar;\n  var placeholderChar = _config$placeholderCh === undefined ? _constants.placeholderCharacter : _config$placeholderCh;\n\n  // We will be iterating over each character in the placeholder and sort of fill it up\n  // with user input\n\n  var placeholder = (0, _utilities.convertMaskToPlaceholder)({ mask: mask, placeholderChar: placeholderChar });\n\n  // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n  var suppressGuide = guide === false && previousConformedInput !== undefined;\n\n  // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n  var indexOfFirstChange = (0, _utilities.getIndexOfFirstChange)(previousConformedInput, userInput);\n\n  // This tells us the number of edited characters and the direction in which they were edited (+/-)\n  var numberOfEditedChars = userInput.length - previousConformedInput.length;\n\n  var userInputArr = (0, _utilities.tokenize)(userInput);\n\n  // In *no guide* mode, we need to know if the user is trying to add a character or not\n  var isAddition = suppressGuide && !(userInput.length < previousConformedInput.length);\n\n  // Unescaping a mask turns a mask like `+\\1 (111) 111-1111` into `+  (111) 111-1111`. That is,\n  // it substituted an escaped character with empty white space. We do that because further down\n  // in the algorithm when we insert user input characters into the placeholder, we don't want the\n  // code to think that we can insert a numeric character in the `1` spot (which when unescaped\n  // stands for *any numeric character*).\n  var unescapedMask = (0, _utilities.unescapeMask)(mask);\n\n  // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `userInputArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n  var numberOfSpliceOperations = 0;\n  for (var i = 0; i < placeholder.length && userInputArr.length > 0; i++) {\n    var shouldJumpAheadInUserInput = i >= indexOfFirstChange && previousConformedInput !== '';\n    var userInputPointer = (shouldJumpAheadInUserInput ? i + numberOfEditedChars : i) - numberOfSpliceOperations;\n\n    if (placeholder[i] === userInputArr[userInputPointer] && userInputArr[userInputPointer] !== placeholderChar) {\n      userInputArr.splice(userInputPointer, 1);\n\n      numberOfSpliceOperations++;\n    }\n  }\n\n  // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n  var conformedString = '';\n\n  // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n  placeholderLoop: for (var _i = 0; _i < placeholder.length; _i++) {\n    var charInPlaceholder = placeholder[_i];\n\n    // We see one. Let's find out what we can put in it.\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (userInputArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (userInputArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          var userInputChar = userInputArr.shift();\n\n          // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n          if (userInputChar === placeholderChar && suppressGuide !== true) {\n            conformedString += placeholderChar;\n\n            // And we go to find the next placeholder character that needs filling\n            continue placeholderLoop;\n\n            // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if ((0, _utilities.isAcceptableCharacter)(userInputChar, unescapedMask[_i])) {\n              // if it is accepted. We map it--performing any necessary transforming along the way,\n              // like upper casing or lower casing.\n              conformedString += (0, _utilities.potentiallyTransformCharacter)(userInputChar, unescapedMask[_i]);\n\n              // Since we've mapped this placeholder position. We move on to the next one.\n              continue placeholderLoop;\n            }\n        }\n      }\n\n      // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n      if (suppressGuide === false) {\n        conformedString += placeholder.substr(_i, placeholder.length);\n      }\n\n      // And we break\n      break;\n\n      // Else, the characterInPlaceholder is not a placeholderCharacter. That is, we cannot fill it\n      // with user input. So we just map it to the final output\n    } else {\n        conformedString += charInPlaceholder;\n      }\n  }\n\n  // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n  if (suppressGuide && isAddition === false) {\n    var indexOfLastFilledPlaceholderChar = null;\n\n    // Find the last filled placeholder position and substring from there\n    for (var _i2 = 0; _i2 < conformedString.length; _i2++) {\n      if (placeholder[_i2] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = _i2;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedString = conformedString.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderCharacter` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedString = '';\n    }\n  }\n\n  return {\n    output: conformedString,\n    meta: {\n      input: userInput,\n      mask: mask,\n      guide: guide,\n      placeholderChar: placeholderChar,\n      placeholder: placeholder\n    }\n  };\n}"},{"id":3,"identifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/constants.js","name":"./core/src/constants.js","index":4,"index2":0,"size":694,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/conformToMask.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":1,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/utilities.js","module":"./core/src/utilities.js","moduleName":"./core/src/utilities.js","type":"cjs require","userRequest":"./constants.js","loc":"15:17-42"},{"moduleId":2,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/conformToMask.js","module":"./core/src/conformToMask.js","moduleName":"./core/src/conformToMask.js","type":"cjs require","userRequest":"./constants.js","loc":"10:17-42"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar maskingCharactersEnums = exports.maskingCharactersEnums = {\n  numeric: '1',\n  alphabetic: 'A',\n  alphanumeric: '?',\n  uppercase: 'U',\n  lowercase: 'L',\n  any: '*'\n};\n\nvar maskingCharactersWithDescription = exports.maskingCharactersWithDescription = {\n  '1': 'Any number',\n  'A': 'Any letter',\n  '?': 'Any number or letter',\n  'U': 'Any letter (will be transformed to uppercase)',\n  'L': 'Any letter (will be transformed to lowercase)',\n  '*': 'Any character'\n};\n\nvar maskingCharacters = exports.maskingCharacters = ['1', 'A', '?', 'U', 'L', '*'];\n\nvar placeholderCharacter = exports.placeholderCharacter = '_';"},{"id":4,"identifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/adjustCaretPosition.js","name":"./core/src/adjustCaretPosition.js","index":2,"index2":2,"size":7906,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/componentHelpers.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/componentHelpers.js","module":"./core/src/componentHelpers.js","moduleName":"./core/src/componentHelpers.js","type":"cjs require","userRequest":"./adjustCaretPosition.js","loc":"10:27-62"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = adjustCaretPosition;\n\nvar _utilities = require('./utilities.js');\n\nfunction adjustCaretPosition(_ref) {\n  var _ref$previousConforme = _ref.previousConformedInput;\n  var previousConformedInput = _ref$previousConforme === undefined ? '' : _ref$previousConforme;\n  var _ref$conformToMaskRes = _ref.conformToMaskResults;\n  var conformToMaskResults = _ref$conformToMaskRes === undefined ? {} : _ref$conformToMaskRes;\n  var _ref$currentCaretPosi = _ref.currentCaretPosition;\n  var currentCaretPosition = _ref$currentCaretPosi === undefined ? 0 : _ref$currentCaretPosi;\n\n  if (currentCaretPosition === 0) {\n    return 0;\n  }\n\n  var _conformToMaskResults = conformToMaskResults.output;\n  var conformedInput = _conformToMaskResults === undefined ? '' : _conformToMaskResults;\n  var _conformToMaskResults2 = conformToMaskResults.meta;\n  var meta = _conformToMaskResults2 === undefined ? {} : _conformToMaskResults2;\n  var _meta$input = meta.input;\n  var rawInput = _meta$input === undefined ? '' : _meta$input;\n  var placeholderChar = meta.placeholderChar;\n  var placeholder = meta.placeholder;\n\n  // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n\n  var indexOfFirstChange = (0, _utilities.getIndexOfFirstChange)(previousConformedInput, rawInput);\n\n  // When user modifies string from (444) 444-44__ to (444) 444-444_ while caret is at position\n  // 2, `indexOfChange` would be 12. This is what I call ambiguous change\n  var isAmbiguousChange = indexOfFirstChange - currentCaretPosition > 1;\n\n  // If the change is ambiguous. Our best bet is to keep the caret where it is.\n  if (isAmbiguousChange) {\n    return currentCaretPosition;\n  }\n\n  // True when user tries to add a character. Like, (___) ___-____ to (4___) ___-____\n  var isAddition = !(rawInput.length < previousConformedInput.length);\n\n  // This is true when user has entered more than one character per iteration. This happens\n  // when user pastes or makes a selection and edits\n  var isMultiCharEdit = Math.abs(previousConformedInput.length - rawInput.length) > 1;\n\n  // This is the first character the user entered that needs to be conformed to mask\n  var isFirstChar = rawInput.length === 1;\n\n  // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edit that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace.\n  //\n  // Such cases can also happen when the user presses the backspace while holding down the ALT\n  // key.\n  var isPartialMultiCharEdit = isMultiCharEdit && !isAddition && !isFirstChar;\n\n  // For a mask like (111), if the `previousConformedInput` is (1__) and user attempts to enter\n  // `f` so the `rawInput` becomes (1f__), the new `conformedInput` would be (1__), which is the\n  // same as the original `previousConformedInput`. We handle this case differently for caret\n  // positioning.\n  var possiblyHasRejectedChar = isAddition && (previousConformedInput === conformedInput || conformedInput === placeholder);\n\n  // There's an edge case when the user enters the first character of the mask and it's a mask\n  // delimiter. For example, mask (111) 111-1111, and user enters `(`. In this case, the\n  // `previousConformedInput` would be empty string and conformedInput would be `(___) ___-____`\n  // This case is treated differently in caret positioning.\n  var onlyEnteredAMaskDelimiter = previousConformedInput === '' && conformedInput === placeholder;\n\n  // If operation is paste, that is input goes from (___) ___-___ to (650) 333-3__ in one change,\n  // we want to find the next suitable caret position in the `conformedInput` string. Otherwise,\n  // we always want to use the `placeholder` for our target for caret placement.\n  var baseTargetForCaretPlacement = isMultiCharEdit || isFirstChar ? conformedInput : placeholder;\n\n  // This is true when user attempts to insert a character in a non-placeholder position.\n  // For example, for mask (111) 111-1111, if the user tries to enter a character 5 at position 0\n  // which is before the first `(`, this flag would be `true`.\n  var isCharInsertedInNonPlaceholderIndex = placeholder[indexOfFirstChange] !== placeholderChar;\n\n  // We can reasonably expect that we will adjust the caret position starting from the\n  // original/current caret position\n  var startingSearchIndex = currentCaretPosition;\n\n  // This algorithm doesn't support all cases of multi-character edits, so we just return\n  // the current caret position.\n  //\n  // This works fine for most cases.\n  if (isPartialMultiCharEdit) {\n    return currentCaretPosition;\n\n    // If the operation is a multi-char edit or this is the first character the user is entering,\n    // we start from the beginning of the `conformedInput` string and look for the next\n    // `placeholderChar` to place the caret at it\n  } else if (isMultiCharEdit || isFirstChar) {\n      startingSearchIndex = 0;\n\n      // Else if operation has rejected character, we wanna go back a step and start searching from\n      // there because the caret will have advanced after entering the rejected character\n    } else if (possiblyHasRejectedChar) {\n        startingSearchIndex--;\n\n        // Else if none of the conditions above is true, and the operation is addition, let's start the\n        // search from the first `placeholderChar` position.\n      } else if (isAddition) {\n          for (var i = currentCaretPosition; i < placeholder.length; i++) {\n            var needsAdjustmentByOne = isCharInsertedInNonPlaceholderIndex && !onlyEnteredAMaskDelimiter;\n\n            if (placeholder[i] === placeholderChar) {\n              // So, we found the next `placeholderChar`. But we need to adjust by `1` if the user\n              // made their change in a none-placeholder character position and if that change is not\n              // just a mask delimiter.\n              startingSearchIndex = i + (needsAdjustmentByOne ? 1 : 0);\n              break;\n            }\n          }\n        }\n\n  // At this point, we have determined a reasonable index from which we can begin searching for\n  // the correct caret position and we've put it in `startingSearchIndex`. And we've determined\n  // the base in which to look for the caret position, whether `placeholder` or `conformedInput`.\n  //\n  // Now, if `isAddition`, we seek forward. Otherwise we seek back.\n  if (isAddition || isFirstChar) {\n    for (var _i = startingSearchIndex; _i <= baseTargetForCaretPlacement.length; _i++) {\n      if (\n      // If we're adding, we can position the caret at the next placeholder character.\n      baseTargetForCaretPlacement[_i] === placeholderChar ||\n\n      // This is the end of the target. We cannot move any further. Let's put the caret there.\n      _i === baseTargetForCaretPlacement.length) {\n        // Limiting `i` to the length of the `conformedInput` is a brute force fix for caret\n        // positioning in `!guide` mode. There are a few edge cases which are\n        // solved by this. To see what happens without it, uncomment the line below and run\n        // the test suite\n\n        // return i\n        return _i > conformedInput.length ? conformedInput.length : _i;\n      }\n    }\n  } else {\n    for (var _i2 = startingSearchIndex; _i2 >= 0; _i2--) {\n      // If we're deleting, we stop the caret right before the placeholder character.\n      // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\n      // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\n      // right after the first `6`\n      if (baseTargetForCaretPlacement[_i2 - 1] === placeholderChar ||\n\n      // This is the beginning of the target. We cannot move any further.\n      // Let's put the caret there.\n      _i2 === 0) {\n        return _i2;\n      }\n    }\n  }\n}"},{"id":5,"identifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/componentHelpers.js","name":"./core/src/componentHelpers.js","index":1,"index2":4,"size":3552,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","module":"./angular2/src/angular2TextMask.ts","moduleName":"./angular2/src/angular2TextMask.ts","type":"cjs require","userRequest":"../../core/src/componentHelpers","loc":"11:25-67"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.processComponentChanges = processComponentChanges;\nexports.getComponentInitialState = getComponentInitialState;\nexports.safeSetSelection = safeSetSelection;\n\nvar _adjustCaretPosition = require('./adjustCaretPosition.js');\n\nvar _adjustCaretPosition2 = _interopRequireDefault(_adjustCaretPosition);\n\nvar _conformToMask = require('./conformToMask.js');\n\nvar _conformToMask2 = _interopRequireDefault(_conformToMask);\n\nvar _utilities = require('./utilities.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction processComponentChanges(_ref) {\n  var _ref$userInput = _ref.userInput;\n  var userInput = _ref$userInput === undefined ? '' : _ref$userInput;\n  var _ref$placeholder = _ref.placeholder;\n  var placeholder = _ref$placeholder === undefined ? '' : _ref$placeholder;\n  var _ref$previousConforme = _ref.previousConformedInput;\n  var previousConformedInput = _ref$previousConforme === undefined ? '' : _ref$previousConforme;\n  var _ref$mask = _ref.mask;\n  var mask = _ref$mask === undefined ? '' : _ref$mask;\n  var _ref$guide = _ref.guide;\n  var guide = _ref$guide === undefined ? '' : _ref$guide;\n  var _ref$currentCaretPosi = _ref.currentCaretPosition;\n  var currentCaretPosition = _ref$currentCaretPosi === undefined ? 0 : _ref$currentCaretPosi;\n  var placeholderChar = _ref.placeholderChar;\n\n  var conformToMaskResults = (0, _conformToMask2.default)(userInput, mask, { previousConformedInput: previousConformedInput, guide: guide, placeholderChar: placeholderChar });\n  var outputOfConformToMask = conformToMaskResults.output;\n\n  var adjustedCaretPosition = (0, _adjustCaretPosition2.default)({\n    previousConformedInput: previousConformedInput,\n    conformToMaskResults: conformToMaskResults,\n    currentCaretPosition: currentCaretPosition,\n    placeholderChar: placeholderChar\n  });\n  var valueShouldBeEmpty = outputOfConformToMask === placeholder && adjustedCaretPosition === 0;\n  var conformedInput = valueShouldBeEmpty ? '' : outputOfConformToMask;\n\n  return { conformedInput: conformedInput, adjustedCaretPosition: adjustedCaretPosition };\n}\n\nfunction getComponentInitialState(_ref2) {\n  var inputValue = _ref2.inputValue;\n  var mask = _ref2.mask;\n  var guide = _ref2.guide;\n  var placeholderChar = _ref2.placeholderChar;\n\n  var safeInputValue = getSafeInputValue(inputValue);\n  var needsToBeConformed = safeInputValue.length > 0;\n\n  var _ref3 = needsToBeConformed ? (0, _conformToMask2.default)(safeInputValue, mask, { guide: guide, previousConformedInput: '', placeholderChar: placeholderChar }) : { output: '' };\n\n  var conformedInput = _ref3.output;\n\n\n  return {\n    conformedInput: conformedInput,\n    adjustedCaretPosition: 0,\n    componentPlaceholder: (0, _utilities.convertMaskToPlaceholder)({ mask: mask, placeholderChar: placeholderChar })\n  };\n}\n\nfunction safeSetSelection(element, selectionPosition) {\n  if (document.activeElement === element) {\n    element.setSelectionRange(selectionPosition, selectionPosition, 'none');\n  }\n}\n\nfunction getSafeInputValue(inputValue) {\n  if ((0, _utilities.isString)(inputValue)) {\n    return inputValue;\n  } else if ((0, _utilities.isNumber)(inputValue)) {\n    return String(inputValue);\n  } else if (inputValue === undefined || inputValue === null) {\n    return '';\n  } else {\n    console.log('Text Mask received', inputValue); // eslint-disable-line\n    throw new Error('The `value` provided to Text Mask needs to be a string or a number.');\n  }\n}"},{"id":6,"identifier":"external {\"root\":[\"ng\",\"common\"],\"commonjs\":\"angular2/common\",\"commonjs2\":\"angular2/common\",\"amd\":\"angular2/common\"}","name":"external {\"root\":[\"ng\",\"common\"],\"commonjs\":\"angular2/common\",\"commonjs2\":\"angular2/common\",\"amd\":\"angular2/common\"}","index":7,"index2":6,"size":42,"cacheable":false,"built":false,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","module":"./angular2/src/angular2TextMask.ts","moduleName":"./angular2/src/angular2TextMask.ts","type":"cjs require","userRequest":"angular2/common","loc":"13:15-41"}]},{"id":7,"identifier":"external {\"root\":[\"ng\",\"core\"],\"commonjs\":\"angular2/core\",\"commonjs2\":\"angular2/core\",\"amd\":\"angular2/core\"}","name":"external {\"root\":[\"ng\",\"core\"],\"commonjs\":\"angular2/core\",\"commonjs2\":\"angular2/core\",\"amd\":\"angular2/core\"}","index":6,"index2":5,"size":42,"cacheable":false,"built":false,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","module":"./angular2/src/angular2TextMask.ts","moduleName":"./angular2/src/angular2TextMask.ts","type":"cjs require","userRequest":"angular2/core","loc":"12:13-37"}]}],"filteredModules":0,"origins":[{"moduleId":0,"module":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","moduleName":"./angular2/src/angular2TextMask.ts","loc":"","name":"main","reasons":[]}]}],"modules":[{"id":0,"identifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","name":"./angular2/src/angular2TextMask.ts","index":0,"index2":7,"size":5293,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"failed":false,"errors":0,"warnings":0,"reasons":[],"source":"\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar componentHelpers_1 = require('../../core/src/componentHelpers');\nvar core_1 = require('angular2/core');\nvar common_1 = require('angular2/common');\nvar MaskedInputDirective = (function () {\n    function MaskedInputDirective(el, model) {\n        this.model = model;\n        this.textMaskConfig = { mask: '', guide: true, placeholderCharacter: undefined };\n        this.inputElement = el.nativeElement;\n    }\n    MaskedInputDirective.prototype.setComponentInitialState = function (_a) {\n        var inputValue = _a.inputValue, mask = _a.mask, guide = _a.guide, placeholderChar = _a.placeholderChar;\n        var _b = componentHelpers_1.getComponentInitialState({\n            inputValue: inputValue,\n            mask: mask,\n            guide: guide,\n            placeholderChar: placeholderChar\n        }), conformedInput = _b.conformedInput, componentPlaceholder = _b.componentPlaceholder;\n        this.conformedInput = conformedInput;\n        this.componentPlaceholder = componentPlaceholder;\n        this.inputElement.placeholder = (this.inputElement.placeholder !== undefined) ?\n            this.inputElement.placeholder :\n            this.componentPlaceholder;\n        this.model.valueAccessor.writeValue(conformedInput);\n        this.updateModel(conformedInput);\n    };\n    MaskedInputDirective.prototype.ngOnInit = function (_a) {\n        var _b = _a === void 0 ? this.textMaskConfig : _a, mask = _b.mask, guide = _b.guide, placeholderChar = _b.placeholderCharacter;\n        this.setComponentInitialState({ inputValue: this.model.viewModel, mask: mask, guide: guide, placeholderChar: placeholderChar });\n    };\n    MaskedInputDirective.prototype.ngOnChanges = function (_a) {\n        var textMaskConfig = _a.textMaskConfig;\n        var _b = textMaskConfig.currentValue, currentMask = _b.mask, currentGuide = _b.guide, currentPlaceholderChar = _b.placeholderCharacter, _c = textMaskConfig.previousValue, previousMask = _c.mask, previousGuide = _c.guide, previousPlaceholderChar = _c.placeholderCharacter;\n        if (currentMask !== previousMask ||\n            currentGuide !== previousGuide ||\n            currentPlaceholderChar !== previousPlaceholderChar) {\n            this.setComponentInitialState({\n                inputValue: this.model.viewModel,\n                mask: currentMask,\n                guide: currentGuide,\n                placeholderChar: currentPlaceholderChar\n            });\n        }\n    };\n    MaskedInputDirective.prototype.onInput = function (userInput) {\n        if (userInput === void 0) { userInput = ''; }\n        var _a = this, _b = _a.textMaskConfig, mask = _b.mask, guide = _b.guide, placeholderChar = _b.placeholderCharacter, placeholder = _a.componentPlaceholder, previousConformedInput = _a.conformedInput;\n        var _c = componentHelpers_1.processComponentChanges({\n            userInput: userInput,\n            placeholder: placeholder,\n            previousConformedInput: previousConformedInput,\n            mask: mask,\n            guide: guide,\n            placeholderChar: placeholderChar,\n            currentCaretPosition: this.inputElement.selectionStart\n        }), adjustedCaretPosition = _c.adjustedCaretPosition, conformedInput = _c.conformedInput;\n        this.conformedInput = conformedInput;\n        this.model.valueAccessor.writeValue(conformedInput);\n        componentHelpers_1.safeSetSelection(this.inputElement, adjustedCaretPosition);\n    };\n    MaskedInputDirective.prototype.updateModel = function (conformedUserInput) {\n        this.model.viewToModelUpdate(conformedUserInput);\n    };\n    __decorate([\n        core_1.Input('textMask'), \n        __metadata('design:type', Object)\n    ], MaskedInputDirective.prototype, \"textMaskConfig\", void 0);\n    MaskedInputDirective = __decorate([\n        core_1.Directive({\n            selector: 'input[textMask][ngModel]',\n            host: {\n                '(input)': 'onInput($event.target.value)',\n                '(keyup)': 'updateModel($event.target.value)'\n            }\n        }), \n        __metadata('design:paramtypes', [core_1.ElementRef, common_1.NgModel])\n    ], MaskedInputDirective);\n    return MaskedInputDirective;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = MaskedInputDirective;\nexports.Directive = MaskedInputDirective;\nvar conformToMask_1 = require('../../core/src/conformToMask');\nexports.conformToMask = conformToMask_1.default;\nvar utilities_1 = require('../../core/src/utilities');\nexports.convertMaskToPlaceholder = utilities_1.convertMaskToPlaceholder;\n"},{"id":1,"identifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/utilities.js","name":"./core/src/utilities.js","index":3,"index2":1,"size":3758,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","module":"./angular2/src/angular2TextMask.ts","moduleName":"./angular2/src/angular2TextMask.ts","type":"cjs require","userRequest":"../../core/src/utilities","loc":"94:18-53"},{"moduleId":2,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/conformToMask.js","module":"./core/src/conformToMask.js","moduleName":"./core/src/conformToMask.js","type":"cjs require","userRequest":"./utilities.js","loc":"8:17-42"},{"moduleId":4,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/adjustCaretPosition.js","module":"./core/src/adjustCaretPosition.js","moduleName":"./core/src/adjustCaretPosition.js","type":"cjs require","userRequest":"./utilities.js","loc":"8:17-42"},{"moduleId":5,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/componentHelpers.js","module":"./core/src/componentHelpers.js","moduleName":"./core/src/componentHelpers.js","type":"cjs require","userRequest":"./utilities.js","loc":"18:17-42"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertMaskToPlaceholder = convertMaskToPlaceholder;\nexports.unescapeMask = unescapeMask;\nexports.tokenize = tokenize;\nexports.isAcceptableCharacter = isAcceptableCharacter;\nexports.potentiallyTransformCharacter = potentiallyTransformCharacter;\nexports.getIndexOfFirstChange = getIndexOfFirstChange;\nexports.isString = isString;\nexports.isNumber = isNumber;\n\nvar _constants = require('./constants.js');\n\nfunction convertMaskToPlaceholder(_ref) {\n  var _ref$mask = _ref.mask;\n  var mask = _ref$mask === undefined ? '' : _ref$mask;\n  var _ref$placeholderChar = _ref.placeholderChar;\n  var placeholderChar = _ref$placeholderChar === undefined ? _constants.placeholderCharacter : _ref$placeholderChar;\n\n  if (mask.indexOf(placeholderChar) !== -1) {\n    console.log('Text Mask received placeholder character: ', placeholderChar); // eslint-disable-line\n    console.log('Text Mask received mask: ', mask); // eslint-disable-line\n\n    throw new Error('Placeholder character must not be used as part of the mask. Please specify a character ' + 'that is not present in your mask as your placeholder character.');\n  }\n\n  var escaping = false;\n  var placeholder = '';\n\n  for (var i = 0; i < mask.length; i++) {\n    var character = mask[i];\n\n    if (character === '\\\\' && escaping !== true) {\n      escaping = true;\n      placeholder += '';\n      continue;\n    }\n\n    if (escaping === true) {\n      escaping = false;\n      placeholder += character;\n      continue;\n    }\n\n    placeholder += _constants.maskingCharacters.indexOf(character) !== -1 ? placeholderChar : character;\n  }\n\n  return placeholder;\n}\n\nfunction unescapeMask() {\n  var mask = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n  return mask.replace(/\\\\./g, ' ');\n}\n\nfunction tokenize() {\n  var string = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n  return string.split('');\n}\n\nfunction isAcceptableCharacter() {\n  var character = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var maskingCharacter = arguments[1];\n\n  switch (maskingCharacter) {\n    case _constants.maskingCharactersEnums.numeric:\n      return isNumeric(character);\n\n    case _constants.maskingCharactersEnums.uppercase:\n    case _constants.maskingCharactersEnums.lowercase:\n    case _constants.maskingCharactersEnums.alphabetic:\n      return isAlphabetic(character);\n\n    case _constants.maskingCharactersEnums.alphanumeric:\n      return isNumeric(character) || isAlphabetic(character);\n\n    case _constants.maskingCharactersEnums.any:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction potentiallyTransformCharacter() {\n  var character = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var maskingCharacter = arguments[1];\n\n  switch (maskingCharacter) {\n    case _constants.maskingCharactersEnums.uppercase:\n      return character.toUpperCase();\n\n    case _constants.maskingCharactersEnums.lowercase:\n      return character.toLowerCase();\n\n    default:\n      return character;\n  }\n}\n\nfunction isNumeric(character) {\n  return !isNaN(character) && character !== ' ';\n}\n\nfunction isAlphabetic(character) {\n  return (/^[a-zA-Z]+$/.test(character)\n  );\n}\n\nfunction getIndexOfFirstChange(stringOne, stringTwo) {\n  var longestLength = stringOne.length > stringTwo.length ? stringOne.length : stringTwo.length;\n\n  for (var i = 0; i < longestLength; i++) {\n    if (stringOne[i] !== stringTwo[i]) {\n      return i;\n    }\n  }\n\n  return null;\n}\n\nfunction isString(value) {\n  return typeof value === 'string' || value instanceof String;\n}\n\nfunction isNumber(value) {\n  return value && value.length === undefined && !isNaN(value);\n}"},{"id":2,"identifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/conformToMask.js","name":"./core/src/conformToMask.js","index":5,"index2":3,"size":7817,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","module":"./angular2/src/angular2TextMask.ts","moduleName":"./angular2/src/angular2TextMask.ts","type":"cjs require","userRequest":"../../core/src/conformToMask","loc":"92:22-61"},{"moduleId":5,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/componentHelpers.js","module":"./core/src/componentHelpers.js","moduleName":"./core/src/componentHelpers.js","type":"cjs require","userRequest":"./conformToMask.js","loc":"14:21-50"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = conformToMask;\n\nvar _utilities = require('./utilities.js');\n\nvar _constants = require('./constants.js');\n\nfunction conformToMask() {\n  var userInput = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var mask = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n  var config = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n  // These configurations tell us how to conform the mask\n  var _config$guide = config.guide;\n  var guide = _config$guide === undefined ? true : _config$guide;\n  var _config$previousConfo = config.previousConformedInput;\n  var previousConformedInput = _config$previousConfo === undefined ? '' : _config$previousConfo;\n  var _config$placeholderCh = config.placeholderChar;\n  var placeholderChar = _config$placeholderCh === undefined ? _constants.placeholderCharacter : _config$placeholderCh;\n\n  // We will be iterating over each character in the placeholder and sort of fill it up\n  // with user input\n\n  var placeholder = (0, _utilities.convertMaskToPlaceholder)({ mask: mask, placeholderChar: placeholderChar });\n\n  // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n  var suppressGuide = guide === false && previousConformedInput !== undefined;\n\n  // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n  var indexOfFirstChange = (0, _utilities.getIndexOfFirstChange)(previousConformedInput, userInput);\n\n  // This tells us the number of edited characters and the direction in which they were edited (+/-)\n  var numberOfEditedChars = userInput.length - previousConformedInput.length;\n\n  var userInputArr = (0, _utilities.tokenize)(userInput);\n\n  // In *no guide* mode, we need to know if the user is trying to add a character or not\n  var isAddition = suppressGuide && !(userInput.length < previousConformedInput.length);\n\n  // Unescaping a mask turns a mask like `+\\1 (111) 111-1111` into `+  (111) 111-1111`. That is,\n  // it substituted an escaped character with empty white space. We do that because further down\n  // in the algorithm when we insert user input characters into the placeholder, we don't want the\n  // code to think that we can insert a numeric character in the `1` spot (which when unescaped\n  // stands for *any numeric character*).\n  var unescapedMask = (0, _utilities.unescapeMask)(mask);\n\n  // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `userInputArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n  var numberOfSpliceOperations = 0;\n  for (var i = 0; i < placeholder.length && userInputArr.length > 0; i++) {\n    var shouldJumpAheadInUserInput = i >= indexOfFirstChange && previousConformedInput !== '';\n    var userInputPointer = (shouldJumpAheadInUserInput ? i + numberOfEditedChars : i) - numberOfSpliceOperations;\n\n    if (placeholder[i] === userInputArr[userInputPointer] && userInputArr[userInputPointer] !== placeholderChar) {\n      userInputArr.splice(userInputPointer, 1);\n\n      numberOfSpliceOperations++;\n    }\n  }\n\n  // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n  var conformedString = '';\n\n  // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n  placeholderLoop: for (var _i = 0; _i < placeholder.length; _i++) {\n    var charInPlaceholder = placeholder[_i];\n\n    // We see one. Let's find out what we can put in it.\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (userInputArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (userInputArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          var userInputChar = userInputArr.shift();\n\n          // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n          if (userInputChar === placeholderChar && suppressGuide !== true) {\n            conformedString += placeholderChar;\n\n            // And we go to find the next placeholder character that needs filling\n            continue placeholderLoop;\n\n            // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if ((0, _utilities.isAcceptableCharacter)(userInputChar, unescapedMask[_i])) {\n              // if it is accepted. We map it--performing any necessary transforming along the way,\n              // like upper casing or lower casing.\n              conformedString += (0, _utilities.potentiallyTransformCharacter)(userInputChar, unescapedMask[_i]);\n\n              // Since we've mapped this placeholder position. We move on to the next one.\n              continue placeholderLoop;\n            }\n        }\n      }\n\n      // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n      if (suppressGuide === false) {\n        conformedString += placeholder.substr(_i, placeholder.length);\n      }\n\n      // And we break\n      break;\n\n      // Else, the characterInPlaceholder is not a placeholderCharacter. That is, we cannot fill it\n      // with user input. So we just map it to the final output\n    } else {\n        conformedString += charInPlaceholder;\n      }\n  }\n\n  // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n  if (suppressGuide && isAddition === false) {\n    var indexOfLastFilledPlaceholderChar = null;\n\n    // Find the last filled placeholder position and substring from there\n    for (var _i2 = 0; _i2 < conformedString.length; _i2++) {\n      if (placeholder[_i2] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = _i2;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedString = conformedString.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderCharacter` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedString = '';\n    }\n  }\n\n  return {\n    output: conformedString,\n    meta: {\n      input: userInput,\n      mask: mask,\n      guide: guide,\n      placeholderChar: placeholderChar,\n      placeholder: placeholder\n    }\n  };\n}"},{"id":3,"identifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/constants.js","name":"./core/src/constants.js","index":4,"index2":0,"size":694,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/conformToMask.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":1,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/utilities.js","module":"./core/src/utilities.js","moduleName":"./core/src/utilities.js","type":"cjs require","userRequest":"./constants.js","loc":"15:17-42"},{"moduleId":2,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/conformToMask.js","module":"./core/src/conformToMask.js","moduleName":"./core/src/conformToMask.js","type":"cjs require","userRequest":"./constants.js","loc":"10:17-42"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar maskingCharactersEnums = exports.maskingCharactersEnums = {\n  numeric: '1',\n  alphabetic: 'A',\n  alphanumeric: '?',\n  uppercase: 'U',\n  lowercase: 'L',\n  any: '*'\n};\n\nvar maskingCharactersWithDescription = exports.maskingCharactersWithDescription = {\n  '1': 'Any number',\n  'A': 'Any letter',\n  '?': 'Any number or letter',\n  'U': 'Any letter (will be transformed to uppercase)',\n  'L': 'Any letter (will be transformed to lowercase)',\n  '*': 'Any character'\n};\n\nvar maskingCharacters = exports.maskingCharacters = ['1', 'A', '?', 'U', 'L', '*'];\n\nvar placeholderCharacter = exports.placeholderCharacter = '_';"},{"id":4,"identifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/adjustCaretPosition.js","name":"./core/src/adjustCaretPosition.js","index":2,"index2":2,"size":7906,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/componentHelpers.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/componentHelpers.js","module":"./core/src/componentHelpers.js","moduleName":"./core/src/componentHelpers.js","type":"cjs require","userRequest":"./adjustCaretPosition.js","loc":"10:27-62"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = adjustCaretPosition;\n\nvar _utilities = require('./utilities.js');\n\nfunction adjustCaretPosition(_ref) {\n  var _ref$previousConforme = _ref.previousConformedInput;\n  var previousConformedInput = _ref$previousConforme === undefined ? '' : _ref$previousConforme;\n  var _ref$conformToMaskRes = _ref.conformToMaskResults;\n  var conformToMaskResults = _ref$conformToMaskRes === undefined ? {} : _ref$conformToMaskRes;\n  var _ref$currentCaretPosi = _ref.currentCaretPosition;\n  var currentCaretPosition = _ref$currentCaretPosi === undefined ? 0 : _ref$currentCaretPosi;\n\n  if (currentCaretPosition === 0) {\n    return 0;\n  }\n\n  var _conformToMaskResults = conformToMaskResults.output;\n  var conformedInput = _conformToMaskResults === undefined ? '' : _conformToMaskResults;\n  var _conformToMaskResults2 = conformToMaskResults.meta;\n  var meta = _conformToMaskResults2 === undefined ? {} : _conformToMaskResults2;\n  var _meta$input = meta.input;\n  var rawInput = _meta$input === undefined ? '' : _meta$input;\n  var placeholderChar = meta.placeholderChar;\n  var placeholder = meta.placeholder;\n\n  // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n\n  var indexOfFirstChange = (0, _utilities.getIndexOfFirstChange)(previousConformedInput, rawInput);\n\n  // When user modifies string from (444) 444-44__ to (444) 444-444_ while caret is at position\n  // 2, `indexOfChange` would be 12. This is what I call ambiguous change\n  var isAmbiguousChange = indexOfFirstChange - currentCaretPosition > 1;\n\n  // If the change is ambiguous. Our best bet is to keep the caret where it is.\n  if (isAmbiguousChange) {\n    return currentCaretPosition;\n  }\n\n  // True when user tries to add a character. Like, (___) ___-____ to (4___) ___-____\n  var isAddition = !(rawInput.length < previousConformedInput.length);\n\n  // This is true when user has entered more than one character per iteration. This happens\n  // when user pastes or makes a selection and edits\n  var isMultiCharEdit = Math.abs(previousConformedInput.length - rawInput.length) > 1;\n\n  // This is the first character the user entered that needs to be conformed to mask\n  var isFirstChar = rawInput.length === 1;\n\n  // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edit that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace.\n  //\n  // Such cases can also happen when the user presses the backspace while holding down the ALT\n  // key.\n  var isPartialMultiCharEdit = isMultiCharEdit && !isAddition && !isFirstChar;\n\n  // For a mask like (111), if the `previousConformedInput` is (1__) and user attempts to enter\n  // `f` so the `rawInput` becomes (1f__), the new `conformedInput` would be (1__), which is the\n  // same as the original `previousConformedInput`. We handle this case differently for caret\n  // positioning.\n  var possiblyHasRejectedChar = isAddition && (previousConformedInput === conformedInput || conformedInput === placeholder);\n\n  // There's an edge case when the user enters the first character of the mask and it's a mask\n  // delimiter. For example, mask (111) 111-1111, and user enters `(`. In this case, the\n  // `previousConformedInput` would be empty string and conformedInput would be `(___) ___-____`\n  // This case is treated differently in caret positioning.\n  var onlyEnteredAMaskDelimiter = previousConformedInput === '' && conformedInput === placeholder;\n\n  // If operation is paste, that is input goes from (___) ___-___ to (650) 333-3__ in one change,\n  // we want to find the next suitable caret position in the `conformedInput` string. Otherwise,\n  // we always want to use the `placeholder` for our target for caret placement.\n  var baseTargetForCaretPlacement = isMultiCharEdit || isFirstChar ? conformedInput : placeholder;\n\n  // This is true when user attempts to insert a character in a non-placeholder position.\n  // For example, for mask (111) 111-1111, if the user tries to enter a character 5 at position 0\n  // which is before the first `(`, this flag would be `true`.\n  var isCharInsertedInNonPlaceholderIndex = placeholder[indexOfFirstChange] !== placeholderChar;\n\n  // We can reasonably expect that we will adjust the caret position starting from the\n  // original/current caret position\n  var startingSearchIndex = currentCaretPosition;\n\n  // This algorithm doesn't support all cases of multi-character edits, so we just return\n  // the current caret position.\n  //\n  // This works fine for most cases.\n  if (isPartialMultiCharEdit) {\n    return currentCaretPosition;\n\n    // If the operation is a multi-char edit or this is the first character the user is entering,\n    // we start from the beginning of the `conformedInput` string and look for the next\n    // `placeholderChar` to place the caret at it\n  } else if (isMultiCharEdit || isFirstChar) {\n      startingSearchIndex = 0;\n\n      // Else if operation has rejected character, we wanna go back a step and start searching from\n      // there because the caret will have advanced after entering the rejected character\n    } else if (possiblyHasRejectedChar) {\n        startingSearchIndex--;\n\n        // Else if none of the conditions above is true, and the operation is addition, let's start the\n        // search from the first `placeholderChar` position.\n      } else if (isAddition) {\n          for (var i = currentCaretPosition; i < placeholder.length; i++) {\n            var needsAdjustmentByOne = isCharInsertedInNonPlaceholderIndex && !onlyEnteredAMaskDelimiter;\n\n            if (placeholder[i] === placeholderChar) {\n              // So, we found the next `placeholderChar`. But we need to adjust by `1` if the user\n              // made their change in a none-placeholder character position and if that change is not\n              // just a mask delimiter.\n              startingSearchIndex = i + (needsAdjustmentByOne ? 1 : 0);\n              break;\n            }\n          }\n        }\n\n  // At this point, we have determined a reasonable index from which we can begin searching for\n  // the correct caret position and we've put it in `startingSearchIndex`. And we've determined\n  // the base in which to look for the caret position, whether `placeholder` or `conformedInput`.\n  //\n  // Now, if `isAddition`, we seek forward. Otherwise we seek back.\n  if (isAddition || isFirstChar) {\n    for (var _i = startingSearchIndex; _i <= baseTargetForCaretPlacement.length; _i++) {\n      if (\n      // If we're adding, we can position the caret at the next placeholder character.\n      baseTargetForCaretPlacement[_i] === placeholderChar ||\n\n      // This is the end of the target. We cannot move any further. Let's put the caret there.\n      _i === baseTargetForCaretPlacement.length) {\n        // Limiting `i` to the length of the `conformedInput` is a brute force fix for caret\n        // positioning in `!guide` mode. There are a few edge cases which are\n        // solved by this. To see what happens without it, uncomment the line below and run\n        // the test suite\n\n        // return i\n        return _i > conformedInput.length ? conformedInput.length : _i;\n      }\n    }\n  } else {\n    for (var _i2 = startingSearchIndex; _i2 >= 0; _i2--) {\n      // If we're deleting, we stop the caret right before the placeholder character.\n      // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\n      // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\n      // right after the first `6`\n      if (baseTargetForCaretPlacement[_i2 - 1] === placeholderChar ||\n\n      // This is the beginning of the target. We cannot move any further.\n      // Let's put the caret there.\n      _i2 === 0) {\n        return _i2;\n      }\n    }\n  }\n}"},{"id":5,"identifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/text-mask/core/src/componentHelpers.js","name":"./core/src/componentHelpers.js","index":1,"index2":4,"size":3552,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","module":"./angular2/src/angular2TextMask.ts","moduleName":"./angular2/src/angular2TextMask.ts","type":"cjs require","userRequest":"../../core/src/componentHelpers","loc":"11:25-67"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.processComponentChanges = processComponentChanges;\nexports.getComponentInitialState = getComponentInitialState;\nexports.safeSetSelection = safeSetSelection;\n\nvar _adjustCaretPosition = require('./adjustCaretPosition.js');\n\nvar _adjustCaretPosition2 = _interopRequireDefault(_adjustCaretPosition);\n\nvar _conformToMask = require('./conformToMask.js');\n\nvar _conformToMask2 = _interopRequireDefault(_conformToMask);\n\nvar _utilities = require('./utilities.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction processComponentChanges(_ref) {\n  var _ref$userInput = _ref.userInput;\n  var userInput = _ref$userInput === undefined ? '' : _ref$userInput;\n  var _ref$placeholder = _ref.placeholder;\n  var placeholder = _ref$placeholder === undefined ? '' : _ref$placeholder;\n  var _ref$previousConforme = _ref.previousConformedInput;\n  var previousConformedInput = _ref$previousConforme === undefined ? '' : _ref$previousConforme;\n  var _ref$mask = _ref.mask;\n  var mask = _ref$mask === undefined ? '' : _ref$mask;\n  var _ref$guide = _ref.guide;\n  var guide = _ref$guide === undefined ? '' : _ref$guide;\n  var _ref$currentCaretPosi = _ref.currentCaretPosition;\n  var currentCaretPosition = _ref$currentCaretPosi === undefined ? 0 : _ref$currentCaretPosi;\n  var placeholderChar = _ref.placeholderChar;\n\n  var conformToMaskResults = (0, _conformToMask2.default)(userInput, mask, { previousConformedInput: previousConformedInput, guide: guide, placeholderChar: placeholderChar });\n  var outputOfConformToMask = conformToMaskResults.output;\n\n  var adjustedCaretPosition = (0, _adjustCaretPosition2.default)({\n    previousConformedInput: previousConformedInput,\n    conformToMaskResults: conformToMaskResults,\n    currentCaretPosition: currentCaretPosition,\n    placeholderChar: placeholderChar\n  });\n  var valueShouldBeEmpty = outputOfConformToMask === placeholder && adjustedCaretPosition === 0;\n  var conformedInput = valueShouldBeEmpty ? '' : outputOfConformToMask;\n\n  return { conformedInput: conformedInput, adjustedCaretPosition: adjustedCaretPosition };\n}\n\nfunction getComponentInitialState(_ref2) {\n  var inputValue = _ref2.inputValue;\n  var mask = _ref2.mask;\n  var guide = _ref2.guide;\n  var placeholderChar = _ref2.placeholderChar;\n\n  var safeInputValue = getSafeInputValue(inputValue);\n  var needsToBeConformed = safeInputValue.length > 0;\n\n  var _ref3 = needsToBeConformed ? (0, _conformToMask2.default)(safeInputValue, mask, { guide: guide, previousConformedInput: '', placeholderChar: placeholderChar }) : { output: '' };\n\n  var conformedInput = _ref3.output;\n\n\n  return {\n    conformedInput: conformedInput,\n    adjustedCaretPosition: 0,\n    componentPlaceholder: (0, _utilities.convertMaskToPlaceholder)({ mask: mask, placeholderChar: placeholderChar })\n  };\n}\n\nfunction safeSetSelection(element, selectionPosition) {\n  if (document.activeElement === element) {\n    element.setSelectionRange(selectionPosition, selectionPosition, 'none');\n  }\n}\n\nfunction getSafeInputValue(inputValue) {\n  if ((0, _utilities.isString)(inputValue)) {\n    return inputValue;\n  } else if ((0, _utilities.isNumber)(inputValue)) {\n    return String(inputValue);\n  } else if (inputValue === undefined || inputValue === null) {\n    return '';\n  } else {\n    console.log('Text Mask received', inputValue); // eslint-disable-line\n    throw new Error('The `value` provided to Text Mask needs to be a string or a number.');\n  }\n}"},{"id":6,"identifier":"external {\"root\":[\"ng\",\"common\"],\"commonjs\":\"angular2/common\",\"commonjs2\":\"angular2/common\",\"amd\":\"angular2/common\"}","name":"external {\"root\":[\"ng\",\"common\"],\"commonjs\":\"angular2/common\",\"commonjs2\":\"angular2/common\",\"amd\":\"angular2/common\"}","index":7,"index2":6,"size":42,"cacheable":false,"built":false,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","module":"./angular2/src/angular2TextMask.ts","moduleName":"./angular2/src/angular2TextMask.ts","type":"cjs require","userRequest":"angular2/common","loc":"13:15-41"}]},{"id":7,"identifier":"external {\"root\":[\"ng\",\"core\"],\"commonjs\":\"angular2/core\",\"commonjs2\":\"angular2/core\",\"amd\":\"angular2/core\"}","name":"external {\"root\":[\"ng\",\"core\"],\"commonjs\":\"angular2/core\",\"commonjs2\":\"angular2/core\",\"amd\":\"angular2/core\"}","index":6,"index2":5,"size":42,"cacheable":false,"built":false,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/mk/Code/github/msafi/text-mask/node_modules/ts-loader/index.js!/Users/mk/Code/github/msafi/text-mask/angular2/src/angular2TextMask.ts","module":"./angular2/src/angular2TextMask.ts","moduleName":"./angular2/src/angular2TextMask.ts","type":"cjs require","userRequest":"angular2/core","loc":"12:13-37"}]}],"filteredModules":0,"children":[]}